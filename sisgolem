#! /usr/bin/env python3
import re
import time
import uuid
import argparse
import xml.etree.ElementTree as et
from collections import OrderedDict

import networking as net
import golemio as io
import parsing as ps

settings_page = 'settings.xml'

def check_classes(session, auth, class_list, term=[""], keyword=""):
    '''
    Checks if a list of classes given by class_list are available on SIS
    and optionally a term to search the classes in (Defaults to current term)
    Returns list of classes currently available on SIS
    '''
    subjects = {cls[:4] : [y[5:] for y in class_list if y[:4] == cls[:4]] for cls in class_list}
    criteria = [(s,t) for s in subjects for t in term]

    available_classes = []
    try:
        for c in criteria:
            classes = net.search_classes(session, auth, course_subject=c[0], term=c[1],title_keyword=keyword)
            if not classes:
                io.log('No results')
            else:
                for cls in classes:
                    if cls[2] in class_list or cls[2][:4] in class_list:
                        #io.log('Available class: ' + cls[2])
                        available_classes.append(cls)

        not_found = [cls for cls in class_list if cls not in [x[2] for x in available_classes] and len(cls) != 4]
        if not_found:
            io.log("Classes not found")
        for cls in not_found:
            print(cls)

    except Exception as e:
        io.log(str(e))
        return []
    return available_classes


def monitor_classes(session, auth, class_list):
    '''
    Periodically checks if a list of classes given by class_list are available on SIS
    Prints new classes as they become available
    '''
    working_classes = OrderedDict()
    try:
        while True:
            classes = check_classes(session, auth, class_list)
            if classes:
                new_classes = []
                for cls in classes:
                    if cls[7] not in working_classes:
                        working_classes[cls[7]] = cls
                        new_classes.append(cls)
                if(new_classes):
                    io.output(new_classes, display_dict)
                io.log("New Classes: " + str(len(new_classes)))
                io.log("Old Classes: " + str(len(working_classes) - len(new_classes)))

                #io.output([x for x in working_classes.values()], display_dict)
                time.sleep(seconds_between_requests)
    except KeyboardInterrupt:
        print()
        io.log("Exit")


def main():
    class_list = []

    root = et.parse(settings_page).getroot()
    authentication = (root.find('username').text,root.find('password').text)
    input_file = root.find('inputFile').text
    output_file = root.find('outputFile').text
    display_dict = [(x.tag,int(x.text)) for x in root.find('display')]

    parser = argparse.ArgumentParser()
    parser.add_argument("classes", help="the classes to search for", nargs="*")
    parser.add_argument("-a", "--auth", help="username:password", action="store")
    # parser.add_argument("-v","--verbose",help="modify output verbosity",type=int,choices=[0,1,2],default=2)
    parser.add_argument("-o", "--output", help="an output csv file", action="store",default=" ", nargs="?")
    parser.add_argument("-i", "--input", help="an input csv file", action="store", default=" ",nargs="?")
    parser.add_argument("-t", "--terms",help="the specified terms", nargs="+",default=[''])

    results = parser.parse_args()
    # global verbose
    # verbose = results.verbose
    if results.classes:
        class_list = [cls.upper() if len(cls) == 4 else cls[:4].upper() + " " + cls[4:] for cls in results.classes]
    term_list = [term.title()[:len(term)-4] + (" " if term else "") + term[len(term)-4:] for term in results.terms]
    if results.auth:
        authentication = (results.auth.split(':',1)[0],results.auth.split(':',1)[1])
    if results.input:
        input_file = None if results.input is " " else results.input
    if results.output:
        output_file = None if results.output is " " else results.output
    if input_file:
        class_list = class_list + read_csv(input_file)

    if not class_list:
        parser.print_help()

    session = net.get_session()
    classes = check_classes(session, authentication, class_list, term=term_list)

    if output_file:
        io.write_csv(output_file, classes)


    io.output(classes, display_dict)


if __name__ == '__main__':
    main()
